% Let's solve Ax = b 
A = [5, -3, 2; -3, 8, 4; 2, 4, -9]

A =

     5    -3     2
    -3     8     4
     2     4    -9

b = [10; 20; 9]

b =

    10
    20
     9

% Note the division operator "/" is different than backslash operator "\"
x = A\b

x =

    3.4442
    3.1982
    1.1868

c = A * x

c =

   10.0000
   20.0000
    9.0000

% Gauss-Jordan reduction uses augmented matrix to row-reduced echelon form
% Form the augmented matrix
C = [A, b]

C =

     5    -3     2    10
    -3     8     4    20
     2     4    -9     9

%rref matrix
Cr = rref(C)

Cr =

    1.0000         0         0    3.4442
         0    1.0000         0    3.1982
         0         0    1.0000    1.1868

% This is usefule for checking howework solutions
% We can also use the eigenvalue problem A * v = lambda * v
% We want to find v and lambda such that we satisfy the above equation
% Usually this is solved by |A - lambda * I| = 0 where we can sub into the 
% the eigenvalus into eigenvalue problem to find the eigenvectors. 
[V, D] = eig(A)

V =

   -0.1709    0.8729    0.4570
   -0.2365    0.4139   -0.8791
    0.9565    0.2583   -0.1357


D =

  -10.3463         0         0
         0    4.1693         0
         0         0   10.1770

% V is the matrix containing the eigenvectors of A as its columns
% D is the matrix that contains the eigenvalues of A on its diagonal
% Let's check if the second eigenvector and eigenvalue satisfy A * v = lambda * v
v2 = V(:,2)

v2 =

    0.8729
    0.4139
    0.2583

lamda2 = D(2,2)

lamda2 =

    4.1693

A * v2 - lambda2 * v
{Undefined function or variable 'lambda2'.
} 
A * v2 - lamda2 * V

ans =

    4.3518         0    1.7341
    2.7117   -0.0000    5.3908
   -2.9110    0.0000    1.6426

% Could also do: 
A * V(:, 2) - D(2, 2) * V(:, 2)

ans =

   1.0e-15 *

         0
   -0.8882
    0.8882

format long g
A * V(:, 2) - D(2, 2) * V(:, 2)

ans =

                         0
     -8.88178419700125e-16
      8.88178419700125e-16

format long 
A * V(:, 2) - D(2, 2) * V(:, 2)

ans =

   1.0e-15 *

                   0
  -0.888178419700125
   0.888178419700125

help format
 <strong>format</strong> Set output format.
    <strong>format</strong> with no inputs sets the output format to the default appropriate
    for the class of the variable. For float variables, the default is
    <strong>format</strong> SHORT.
 
    <strong>format</strong> does not affect how MATLAB computations are done. Computations
    on float variables, namely single or double, are done in appropriate
    floating point precision, no matter how those variables are displayed. 
    Computations on integer variables are done natively in integer. Integer
    variables are always displayed to the appropriate number of digits for
    the class, for example, 3 digits to display the INT8 range -128:127.
    <strong>format</strong> SHORT and LONG do not affect the display of integer variables.
 
    <strong>format</strong> may be used to switch between different output display formats
    of all float variables as follows:
      <strong>format</strong> SHORT     Scaled fixed point format with 5 digits.
      <strong>format</strong> LONG      Scaled fixed point format with 15 digits for double
                       and 7 digits for single.
      <strong>format</strong> SHORTE    Floating point format with 5 digits.
      <strong>format</strong> LONGE     Floating point format with 15 digits for double and
                       7 digits for single.
      <strong>format</strong> SHORTG    Best of fixed or floating point format with 5 
                       digits.
      <strong>format</strong> LONGG     Best of fixed or floating point format with 15 
                       digits for double and 7 digits for single.
      <strong>format</strong> SHORTENG  Engineering format that has at least 5 digits
                       and a power that is a multiple of three
      <strong>format</strong> LONGENG   Engineering format that has exactly 16 significant
                       digits and a power that is a multiple of three.
 
    <strong>format</strong> may be used to switch between different output display formats
    of all numeric variables as follows:
      <strong>format</strong> HEX     Hexadecimal format.
      <strong>format</strong> +       The symbols +, - and blank are printed 
                     for positive, negative and zero elements.
                     Imaginary parts are ignored.
      <strong>format</strong> BANK    Fixed format for dollars and cents.
      <strong>format</strong> RAT     Approximation by ratio of small integers.  Numbers
                     with a large numerator or large denominator are
                     replaced by *.
 
    <strong>format</strong> may be used to affect the spacing in the display of all
    variables as follows:
      <strong>format</strong> COMPACT Suppresses extra line-feeds.
      <strong>format</strong> LOOSE   Puts the extra line-feeds back in.
 
    Example:
       format short, pi, single(pi)
    displays both double and single pi with 5 digits as 3.1416 while
       format long, pi, single(pi)
    displays pi as 3.141592653589793 and single(pi) as 3.1415927.
 
       format, intmax('uint64'), realmax
    shows these values as 18446744073709551615 and 1.7977e+308 while
       format hex, intmax('uint64'), realmax
    shows them as ffffffffffffffff and 7fefffffffffffff respectively.
    The HEX display corresponds to the internal representation of the value
    and is not the same as the hexadecimal notation in the C programming
    language.
 
    See also <a href="matlab:help disp">disp</a>, <a href="matlab:help display">display</a>, <a href="matlab:help isnumeric">isnumeric</a>, <a href="matlab:help isfloat">isfloat</a>, <a href="matlab:help isinteger">isinteger</a>.

    <a href="matlab:doc format">Reference page for format</a>

format short
A * V(:, 2) - D(2, 2) * V(:, 2)

ans =

   1.0e-15 *

         0
   -0.8882
    0.8882

format long
A * V(:, 2) - D(2, 2) * V(:, 2)

ans =

   1.0e-15 *

                   0
  -0.888178419700125
   0.888178419700125

format longe
A * V(:, 2) - D(2, 2) * V(:, 2)

ans =

                         0
    -8.881784197001252e-16
     8.881784197001252e-16

format longeng
A * V(:, 2) - D(2, 2) * V(:, 2)

ans =

    0.00000000000000e+000
   -888.178419700125e-018
    888.178419700125e-018

format longg
A * V(:, 2) - D(2, 2) * V(:, 2)

ans =

                         0
     -8.88178419700125e-16
      8.88178419700125e-16

diary off
% LU factorization of a square matrix, L is lower triagular and U is upper triagular
% L * U = A
[L, U] = lu(A)

L =

                         1                         0                         0
                      -0.6                         1                         0
                       0.4         0.838709677419355                         1


U =

                         5                        -3                         2
                         0                       6.2                       5.2
                         0                         0         -14.1612903225806

% QR factorization, Q is orthogonal matrix and R is upper triagular
% Q * R = A
[Q, R] = qr(A)

Q =

        -0.811107105653813        -0.135174466341799        -0.569063376793046
         0.486664263392288        -0.695653960929748          -0.5284159927364
        -0.324442842261525        -0.705544775540123         0.630034452878016


R =

         -6.16441400296898          5.02886405505364          3.24442842261525
                         0         -7.98188739057308          3.29693820345852
                         0                         0         -8.92210080043383

% If you have a positive definite matrix A, you can factorize the matrix 
% Where R is a upper triangular matrix R' * R = A
R = chol(A)
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('chol')" style="font-weight:bold">chol</a>
Matrix must be positive definite.
} 
A

A =

     5    -3     2
    -3     8     4
     2     4    -9

% Singular value decomposition returns two orthogonal matrices U and V and 
% and a diagonal matrix D with the singular values of A as diagonal entries
[U, D, V] = svd(A)

U =

         -0.17088401273012         0.456980709199358         0.872907375162396
        -0.236484594067271        -0.879064550542719         0.413908870100612
         0.956490298415039        -0.135698737646224         0.258286975357123


D =

          10.3462827629963                         0                         0
                         0          10.1770154159913                         0
                         0                         0          4.16926734700497


V =

         0.170884012730122         0.456980709199358         0.872907375162396
         0.236484594067268         -0.87906455054272         0.413908870100612
        -0.956490298415039         -0.13569873764622         0.258286975357123

% Let's do a best fit using plot
x = [5, 10, 20, 50, 100];
y = [15, 33, 53, 140, 301];
plot(x, y, 'o')
% Let's compare different fits using norm of residual
x = 0:pi/30:pi/3;
y = sin(x) + rand(size(x))/100;
plot(x, y, 'o')
% Given two vectors x, y the command a = polyfit(x, y, n) fits a polynomial of
% of order n through data points (xi, yi) and returns n + 1 coeffiecients of 
% powers of x in row vector a. The coefficients are arranged in decreasing order
% of the powers of x; a=[an, an-1, ... , a1, a0]
% Given data vector x and the coefficients of a polynomial in a row vector a 
% the command y = polyval(a, x) evaluates the polynomial at the data points
% xi. IF a has 5 elements then the polynomial to be evaluated would be 4th order
m = [5, 10, 20, 50, 100];
d = [15.5, 33.07, 53.39, 140.24, 301.03];
g = 9.81;
F = m/1000*g;
a = polyfit(d, F, 1);
% make a finer grid on d 
d_fit = 0: 10:300;
% eval polynomial at new points 
F_fit = polyval(a, d_fit);
plot(d, F, 'o', d_fit, F_fit)
close all
plot(d, F, 'o', d_fit, F_fit)
xlabel('Displacement \delta (mm)'), ylabel('Force (N)')
k = a(1);
text(100, .32, ['\leftarrow Spring Constant K = ', num2str(k),' N/mm']_
 text(100, .32, ['\leftarrow Spring Constant K = ', num2str(k),' N/mm']_
                                                                       
{Error: Invalid text character. Check for unsupported symbol, invisible character, or pasting of non-ASCII characters.
} 
text(100, .32, ['\leftarrow Spring Constant K = ', num2str(k),' N/mm']
 text(100, .32, ['\leftarrow Spring Constant K = ', num2str(k),' N/mm']
                                                                       
{Error: Invalid expression. When calling a function or indexing a variable, use parentheses. Otherwise, check for mismatched delimiters.
} 
text(100, .32, ['\leftarrow Spring Constant K = ', num2str(k),' N/mm'])
diary off
